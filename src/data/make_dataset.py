# -*- coding: utf-8 -*-

import pandas
import click
import logging
from pathlib import Path
from dotenv import find_dotenv, load_dotenv
from raster import Raster
from utils import get_meta_data_filename, get_rgb_filename
from spatial_index import create_spatial_index
import kml2geojson as k2g
import toml
import time
import pdb


def is_analytic_tif(r_analytic_name, satimg_file_endings):
    """Return True if image is of 'analytic' type."""
    return r_analytic_name.endswith(satimg_file_endings)

def name_begins_with_prefix(r_analytic_name, raw_prefix):
    """Return True if prefix is not None and image file has specific prefix."""
    return r_analytic_name.startswith(raw_prefix) if raw_prefix else True

def valid_entries_in_list(r_analytic_name, satimg_list):
    """Return index to r_analytic_name in satimg_list where its 'doUse' value is True."""
    # boolean index pointing to file entries
    row_ix = (satimg_list.loc[:, "analyticImgName"] == r_analytic_name)
    if sum(row_ix) < 1:
        raise Exception(f"{r_analytic_name} not found in list")
    else:
        # file found at least once
        row_ix = row_ix & satimg_list.loc[:, "doUse"]
        if sum(row_ix) < 1:
            raise Exception(f"{r_analytic_name} found in list, but marked as not useable")
        elif sum(row_ix) > 1:
            raise Exception(f"{r_analytic_name} found more than once and marked as useable")
    return row_ix.values

def is_in_region(row_ix, satimg_list, region):
    """."""
    logger = logging.getLogger(__name__)
    if region is None:
        return True
    # region is supposed to be a list
    region = [region] if type(region) is str else region
    is_OK = any([satimg_list.loc[row_ix, "directory"].str.contains(r, case=False).values.all() for r in region])
    if not is_OK:
        logger.info(f"Omitting {satimg_list.loc[row_ix, 'analyticImgName'].values} because of region filter {region}")
    return is_OK

def convert_kml_to_geojson(labels_path):
    """Generate geojson file from kml/kmz file."""
    logger = logging.getLogger(__name__)
    for file in Path(labels_path).iterdir():
        if file.name.endswith(('.kml', 'kmz')):
            logger.info('Generating geojson from {}'.format(file.name))
            kmlpath = '{}/{}'.format(labels_path, file.name)
            k2g.convert(kmlpath, labels_path)

def make_tiles(r_analytic, images_path, output_filepath, window_size, idx,
               overlap, dtype, scaling_type):
    """Create tiles from satellite image, save to file and return number of tiles created."""
    meta_data_filename = get_meta_data_filename(images_path, r_analytic.name)
    r_visual_rgb_filename = get_rgb_filename(images_path, r_analytic.name)
    # instantiate raster class
    raster = Raster(r_analytic, r_visual_rgb_filename, meta_data_filename)
    # ** create tiles **
    num_tiles = raster.to_tiles(output_path=output_filepath,
                    window_size=window_size,
                    idx=idx,
                    overlap=overlap,
                    dtype=dtype,
                    scaling_type=scaling_type)
    return num_tiles


@click.command()
@click.argument('config_file', type=click.File('r'))
@click.argument('input_filepath', type=click.Path(exists=True))
@click.argument('output_filepath', type=click.Path())
def main(config_file, input_filepath, output_filepath):
    """Generate satellite image tiles."""
    t0 = time.time()
    logger = logging.getLogger(__name__)
    # read parameters governing creation of tiles (will create
    # a nested dictionary structure )
    par = toml.load(config_file)

    # extract parameters from the nested dictionary
    # structure generated by toml.load and check them if reasonable:
    # - list of satellite images (satimg), region filter
    satimg_list_filepath = par["satimg"]["satimg_list_filepath"]
    region = par["satimg"]["region"]
    if region == "None":
        region = None

    # - file name prefix
    raw_prefix = par["satimg"]["raw_prefix"]
    if (raw_prefix == "None") or (raw_prefix == ""):
        raw_prefix = None

    # - file name endings (must be converted to tuple)
    satimg_file_endings = (par["satimg"]["satimg_file_endings"])
    if not isinstance(satimg_file_endings, tuple):
        satimg_file_endings = tuple(satimg_file_endings)

    # - intensity scaling of satimgs
    scaling_type = par["satimg"]["scaling_type"]
    if not scaling_type in ("percentile", "equalize_adapthist"):
        raise Exception("scaling_type must be 'percentile' or 'equalize_adapthist'")

    # - number type of output image files (should be "uint8")
    dtype = par["satimg"]["dtype"]
    if not dtype in ("uint8", "uint16"):
        raise Exception("dtype must be 'uint8' or 'uint16'")

    # - size of image tiles
    window_size = par["satimg"]["window_size"]
    if window_size < 64:
        raise Exception("a window size < 64 does not make sense")

    # - overlap of image tiles
    overlap = par["satimg"]["overlap"]
    if not (0.0 <= overlap < 1.0):
        raise Exception("overlap must be in [0.0 1.0[")

    logger.info('making tiles from region {} into folder {} with raw image filter {}'.format(region,
                                                                                             output_filepath,
                                                                                             raw_prefix or "None"))
    images_path = "{}/images".format(input_filepath)
    labels_path = "{}/labels".format(input_filepath)

    convert_kml_to_geojson(labels_path)
    idx = create_spatial_index(labels_path)
    try:
        logger.info('Reading satellite image list')
        satimg_list = pandas.read_json(satimg_list_filepath)
    except:
        raise Exception(f"Satellite image list ({satimg_list_filepath}) could not be read")

    num_tiles = []
    for r_analytic in Path(images_path).iterdir():
        # checks based on file name
        do_process = is_analytic_tif(r_analytic.name, satimg_file_endings) and \
            name_begins_with_prefix(r_analytic.name, raw_prefix)
        if do_process:
            # checks based on list of satellite images
            row_ix = valid_entries_in_list(r_analytic.name, satimg_list)
            do_process = is_in_region(row_ix, satimg_list, region)
            if do_process:
                num_tiles.append(make_tiles(r_analytic,
                           images_path,
                           output_filepath,
                           window_size,
                           idx,
                           overlap,
                           dtype,
                           scaling_type))
    t1 = time.time()

    logger.info(f"Created {num_tiles} tiles in {t1-t0} s")

if __name__ == '__main__':
    log_fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_fmt)

    # not used in this stub but often useful for finding various files
    project_dir = Path(__file__).resolve().parents[2]

    # find .env automagically by walking up directories until it's found, then
    # load up the .env entries as environment variables
    load_dotenv(find_dotenv())
    main()
