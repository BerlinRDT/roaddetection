# -*- coding: utf-8 -*-

import click
import logging
from pathlib import Path
from dotenv import find_dotenv, load_dotenv
from raster import Raster
from utils import get_meta_data_filename, get_rgb_filename
from spatial_index import create_spatial_index
import kml2geojson as k2g
import toml

# TODOs:
# 1. set up a class ('Tile_gen' or so) to reduce variable clutter
# 2. implement concurrent processing to speed up tile generation

@click.command()
@click.argument('config_file', type=click.File('r'))
def main(config_file):
    """
    Generates satellite image tiles.
    """

    logger = logging.getLogger(__name__)

    # read parameters governing creation of tiles (will create
    # a nested dictionary structure )
    par = toml.load(config_file)

    # extract parameters from the nested dictionary
    # structure generated by toml.load and check them if reasonable:

    # - paths, list of satellite images (satimg), region filter
    input_filepath = par["paths"]["input_filepath"]
    output_filepath = par["paths"]["output_filepath"]
    satimg_list = par["satimg"]["satimg_list"]
    region = par["satimg"]["region"]

    # - file name prefix
    raw_prefix = par["satimg"]["raw_prefix"]
    if (raw_prefix == "None") or (raw_prefix == ""):
        raw_prefix = None

    # - file name endings (must be converted to tuple)
    satimg_file_endings = (par["satimg"]["satimg_file_endings"])
    if not isinstance(satimg_file_endings, tuple):
        satimg_file_endings = tuple(satimg_file_endings)

    # - intensity scaling of satimgs
    scaling_type = par["satimg"]["scaling_type"]
    assert (scaling_type in ("percentile", "equalize_adapthist")),\
    "scaling_type must be 'percentile' or 'equalize_adapthist'"

    # - number type of output image files (should be "uint8")
    dtype = par["satimg"]["dtype"]
    assert (dtype in ("uint8", "uint16")), "dtype must be 'uint8' or 'uint16'"

    # - size of image tiles
    window_size = par["satimg"]["window_size"]
    assert (window_size >= 64), "a window size < 64 does not make sense"

    # - overlap of image tiles
    overlap = par["satimg"]["overlap"]
    assert (0.0 <= overlap < 1.0), "overlap must be in [0.0 1.0["

    logger.info('making tiles from region {} into folder {} with raw image filter {}'.format(region,
                                                                                             output_filepath,
                                                                                             raw_prefix or "None"))
    images_path = "{}/images".format(input_filepath)
    labels_path = "{}/labels".format(input_filepath)

    convert_kml_to_geojson(labels_path)
    idx = create_spatial_index(labels_path)
    make_tiles(images_path,
               output_filepath,
               img_list=satimg_list,
               window_size=window_size,
               idx=idx,
               overlap=overlap,
               dtype=dtype,
               scaling_type=scaling_type,
               raw_prefix_filter=raw_prefix,
               satimg_file_endings=satimg_file_endings,
               region_filter=region)


def make_tiles(images_path,
               output_filepath,
               img_list,
               window_size,
               idx,
               overlap,
               dtype,
               scaling_type,
               raw_prefix_filter,
               satimg_file_endings,
               region_filter):


    for r_analytic in Path(images_path).iterdir():
        if should_make_tiles_from(r_analytic.name,
                                  raw_prefix_filter,
                                  satimg_file_endings,
                                  region_filter,
                                  img_list):

            meta_data_filename = get_meta_data_filename(images_path, r_analytic.name)
            r_visual_rgb_filename = get_rgb_filename(images_path, r_analytic.name)
            raster = Raster(r_analytic, r_visual_rgb_filename, meta_data_filename)
            raster.to_tiles(output_path=output_filepath,
                            window_size=window_size,
                            idx=idx,
                            overlap=overlap,
                            dtype=dtype,
                            scaling_type=scaling_type)


def should_make_tiles_from(r_analytic_name, raw_prefix_filter, satimg_file_endings, region_filter, img_list):
    return is_analytic_tif(r_analytic_name, satimg_file_endings) and \
           name_begins_with_prefix(r_analytic_name, raw_prefix_filter) and \
           is_raster_from_desired_region(r_analytic_name, region_filter, img_list)


def name_begins_with_prefix(r_analytic_name, raw_prefix_filter):
    return r_analytic_name.startswith(raw_prefix_filter) if raw_prefix_filter else True


def is_analytic_tif(r_analytic_name, satimg_file_endings):
    return r_analytic_name.endswith(satimg_file_endings)


def is_raster_from_desired_region(r_analytic_name, region_filter, img_list):
    if (region_filter == "all"):
        return True
    logger = logging.getLogger(__name__)
    filtered_by_region = img_list.loc[img_list.directory.str.contains(region_filter, case=False)]
    shouldIgnore = filtered_by_region.loc[filtered_by_region.analyticImgName.str.contains(r_analytic_name)].empty
    if shouldIgnore:
        logger.info("Ignoring raster {} because of region filter {}".format(r_analytic_name, region_filter))
    return not shouldIgnore


def convert_kml_to_geojson(labels_path):
    logger = logging.getLogger(__name__)

    for file in Path(labels_path).iterdir():
        if file.name.endswith(('.kml', 'kmz')):
            logger.info('Generating geojson from {}'.format(file.name))
            kmlpath = '{}/{}'.format(labels_path, file.name)
            k2g.convert(kmlpath, labels_path)


if __name__ == '__main__':
    log_fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_fmt)

    # not used in this stub but often useful for finding various files
    project_dir = Path(__file__).resolve().parents[2]

    # find .env automagically by walking up directories until it's found, then
    # load up the .env entries as environment variables
    load_dotenv(find_dotenv())

    main()
